# 工具执行健壮性：代码兜底 vs LLM 兜底

## 背景

RRClaw 作为 AI Agent，工具执行结果需要经过两个消费者：
1. **LLM** — 根据结果决定下一步行动
2. **TUI** — 向用户展示执行状态

在实际运行中发现多个边界问题：cargo 输出全在 stderr、超时无提示、失败丢弃 stdout 等。核心问题是：什么该代码处理，什么该让 LLM 兜底？

## 设计原则

| 职责 | 代码层 | LLM 层 |
|------|--------|--------|
| 核心价值 | 不丢数据 + 安全 + 基础设施 | 理解结果 + 错误恢复 + 向用户解释 |
| 典型场景 | stdout/stderr 合并、失败保留部分输出、安全策略检查 | 分析编译错误、决定是否重试、向用户解释原因 |
| 边界 | 代码保证信息完整传递 | LLM 通过 system prompt 学习如何处理 |

## 实现

### 1. execute_tool() 结果格式

```
成功: 直接返回工具输出（无前缀）
失败: [失败] {error}\n[部分输出]\n{stdout}   ← 关键：不丢弃 stdout
错误: [错误] {message}                        ← 系统级异常
```

LLM 通过 `[失败]`/`[错误]` 前缀区分状态，通过 `[部分输出]` 获取失败时的有用信息。

### 2. System Prompt 工具使用指南

```
[工具结果格式]
- 成功: 直接返回工具输出内容
- 失败: 以 [失败] 开头，可能包含 [部分输出] 段
- 错误: 以 [错误] 开头，表示系统级异常

[工具使用规则]
- 命令超时不要盲目重试，先告知用户
- 失败时分析 [部分输出] 定位问题，而不是重试相同命令
- 一个目标最多尝试 3 种不同方式，之后向用户说明情况
- file_read 返回空字符串表示文件为空，不是错误
```

### 3. TUI ToolStatus 显示

| 状态 | 显示格式 |
|------|----------|
| Running | `⏳ cargo test ...` |
| Success | `✓ running 70 tests (共2048字节)` ← 首行预览 |
| Failed | `✗ shell 失败` + 前 3 行错误详情 |

### 4. Shell stdout+stderr 合并

cargo 等工具将编译信息输出到 stderr。成功时合并 stdout+stderr，失败时 stdout 保留在 output 字段。

## 不做的事（避免过度工程化）

- **不加 ToolResult 字段**：不加 exit_code/metadata，当前 output+error 已包含足够信息
- **不加执行计时**：LLM 不需要知道具体耗时，超时场景已有明确错误信息
- **不加重试机制**：让 LLM 自己决定是否重试、怎么重试
- **不改工具输出截断逻辑**：LLM 收到完整内容，truncate_str 只用于日志和 TUI

## 文件变更

| 文件 | 改动 |
|------|------|
| `src/agent/loop_.rs` | execute_tool 保留失败输出 + system prompt 工具指南 + ToolStatus 成功预览 |
| `src/channels/cli.rs` | TUI 失败显示改进（多行错误详情） |
